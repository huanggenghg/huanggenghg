## Java 并发编程实战 读书笔记

### 一、基础知识

线程安全的定义：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的；当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

原子性：不可分割的执行步骤。并发环境中的原子性与事务应用程序中的原子性有着相同的含义——一组语句作为一个不可分割的单元被执行。

竞态条件：在并发编程中，由于不恰当的执行时序而出现不正确的结果的一种非常重要的情况。

复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。

加锁机制：为保持状态的一致性，在单个原子操作中保证更新所有相关的状态变量的机制。

内置锁：Java 提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。**以关键字`synchronized`来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的`synchronized`方法以 Class 对象作为锁。**

重入：如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。可重入锁可避免死锁的情况。

内存可见性：当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

失效数据：一个线程访问多个线程可能会去修改的变量时未进行同步可能获得的一个失效值。

最低安全性：当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air safety）。

非原子的 64 位操作：Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于**非 volatile 类型的 long 和 double 变量，JVM 允许将 64 位的读操作或写操作分解为两个32位的操作**。

有序性：程序执行的顺序按照代码的先后顺序执行。（由于JMM模型中允许编译器和处理器为了效率，进行指令重排序的优化。指令重排序在单线程内表现为串行语义，在多线程中会表现为无序。那么多线程并发编程中，就要考虑如何在多线程环境下可以允许部分指令重排，又要保证有序性）

**volatile 变量**：当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。从内存可见性的角度来看，写入 volatile 变量相当于退出同步代码块，而读取 volatile 变量就相当于进入同步代码块。加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

> volatile /ˈvälədl/
>
> Java 内存模型（Java Memory Model，即JMM）：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的细节。
>
> JMM 中规定所有的变量都存储在主内存（Main Memory）中，每条线程都有自己的工作内存（Work Memory），线程的工作内存中保存了该线程所使用的变量的从主内存中拷贝的副本。线程对于变量的读、写都必须在工作内存中进行，而不能直接读、写主内存中的变量。同时，本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成。![img](https://pic1.zhimg.com/v2-cf02b047fcd7eab8fe4e5e0b59e2e3f0_r.jpg)
>
> 可加性保证：
>
> - 当对 volatile 变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存；
> - 写操作会导致其他线程中的缓存无效。
>
> 有序性保证，volatile 变量读写前后均加上内存屏障，禁止指令重排序：
>
> - LoadLoadBarrier
>   volatile 读操作
>   LoadStoreBarrier
>
> - StoreStoreBarrier
>   volatile 写操作
>   StoreLoadBarrier

发布与逸出：“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用；如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。

线程封闭：仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单方式之一。

Ad-hoc 线程封闭：维护线程封闭性的职责完全由程序实现来承担。

栈封闭：在栈封闭中，只能通过局部变量才能访问对象。

ThreadLocal 类：线程本地变量，在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于 synchronized 的做法是用空间来换时间。

> [ThreadLocal 原理](https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter07/ThreadLocal.html#threadlocal%E5%8E%9F%E7%90%86)
>
> ![img](https://fhfirehuo.github.io/Attacking-Java-Rookie/image/c7/ThreadLocal-2.png)
>
> ThreadLocalMap 和HashMap的功能类似，但是实现上却有很大的不同：
>
> 1. HashMap 的数据结构是数组+链表
> 2. ThreadLocalMap的数据结构仅仅是数组
> 3. HashMap 是通过链地址法解决hash 冲突的问题
> 4. ThreadLocalMap 是通过开放地址法来解决hash 冲突的问题
> 5. HashMap 里面的Entry 内部类的引用都是强引用
> 6. ThreadLocalMap里面的Entry 内部类中的 key 是弱引用，value 是强引用
>
> ThreadLocalMap 采用开放地址法原因：
>
> 1. ThreadLocal 中看到一个属性 HASH_INCREMENT = 0x61c88647 ，0x61c88647 是一个神奇的数字，让哈希码能均匀的分布在 2 的 N 次方的数组里, 即 Entry[] table。
> 2. ThreadLocal 往往存放的数据量不会特别大（而且key 是弱引用又会被垃圾回收，及时让数据量更小），这个时候开放地址法简单的结构会显得更省空间，同时数组的查询效率也是非常高，加上第一点的保障，冲突概率也低。
>
> 为什么要交换：为了防止由于弱引用回收掉中间那个冲突的值后，导致后面冲突的值没办法找到，导致重复 key 出现。

不变性：对象创建以后其状态就不能修改，对象创建以后其状态就不能修改，对象创建以后其状态就不能修改。对象创建以后其状态就不能修改。

### 二、同步容器类

**同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作**。容器上常见的复合操作包括：迭代（反复访问元素，直到遍历完容器中所有元素）、跳转（根据指定顺序找到当前元素的下一个元素）以及条件运算，例如“若没有则添加”（检查在Map 中是否存在键值 K，如果没有，就加入二元组（K, V））。在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。

在设计同步容器类的迭代器时并没有考虑到并发修改的问题，并且它们表现出的行为是“及时失败”（fail-fast）的。这意味着，当它们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException 异常。

隐藏迭代：容器的`hashCode`和`equals`等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样，`containsAll`、`removeAll`和`retainAll`等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。

ConcurrentHashMap：



