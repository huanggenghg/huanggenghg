## Java 虚拟机运行时数据区

### 一、Java 虚拟机运行时数据区

![Java 虚拟机运行时数据区](https://raw.githubusercontent.com/huanggenghg/huanggenghg/main/res/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.drawio.png)

- 程序计数器：唯一无 OOM Error 情况的区域。
- Java 虚拟机栈：每个方法被执行的时候，都会同步创建一个栈帧（Stack Frame）用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息。局部变量表存放了编译期可知的各种 Java 虚拟机基本数据类型、对象引用和 returnAddress 类型。异常情况：StackOverFlowError 异常，OOM 异常。
- 本地方法栈：类似 Java 虚拟机栈，为虚拟机执行本地（Native）方法服务。异常情况：StackOverFlowError 异常，OOM 异常。
- Java 堆：存放对象实例，也为“GC 堆”。异常情况：OOM 异常。
- 方法区：存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。异常情况：OOM 异常。
- 运行时常量池：方法区的一部分，存放 Class 文件中的常量池表（用于存放编译期生成的各种字面量与符号引用）。异常情况：OOM 异常。
- *直接内存：并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。JDK1.4 引入 NIO 的一种基于通道与缓存区的 I/O 方式，使得 Native 函数库可直接进行堆外内存分配。异常情况：OOM 异常。*

### 二、垃圾收集器与内存分配策略

怎么判定哪些对象需要被回收：

- 引用计数法：引用计数器。问题：相互引用无法被回收；
- 可达性分析算法：GC Roots search on Reference Chain，向下搜索过程所形成的“引用链”信息

可作为 GC Roots 的对象：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象。
- Java 虚拟机内部的引用，如本地数据类型对应的 Class 对象，一些常驻的异常对象（比如 NullPointException、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized 关键字）持有的对象。
- 反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。
- 还可有其他对象“临时性”加入

引用：

- 强引用：`Object obj = new Object()`
- 软引用：`SoftReference`实现，在系统将要发生内存溢出异常前，会列入回收范围进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常
- 弱引用：`WeakReference`实现，比软引用更弱。弱引用对象只能生存到下一次垃圾收集发生为止。
- 虚引用：`PhantomReference`实现，最弱，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时能收到一个系统通知。

`finalize()`是对象在第一次被回收标记后逃脱死亡命运的最后一次机会，只要重新与引用链上的任一对象建立关联即可。

回收方法区：回收性价比低、回收内容为废弃的常量和不再使用的类型。

> 废弃的常量：如“java”曾经进入常量池中，但当前系统中已没有一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。
> 不再被使用的类（不一定会进行回收，虚拟机参数进行控制）：
  - 该类所有的实例都已被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。
  - 加载该类的类加载器已被回收。（很难达成。）
  - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

垃圾收集算法：

- 标记-清除算法：内存碎片问题
- 标记-复制算法：内存使用率低，多数对象存活时会产生大量复制的开销
- 标记-整理算法：老年代移动存活对象，“Stop The World”

> 分代收集理论：
>
> 1. 弱分代假说：绝大多数对象都是朝生夕灭的。
> 2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
> 3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

### 三、虚拟机类加载机制

![类的生命周期](https://raw.githubusercontent.com/huanggenghg/huanggenghg/main/res/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.drawio.png)

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，只是为了支持 Java 语言的运行时绑定特性（也称为动态绑定或晚期绑定）。

加载阶段：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口